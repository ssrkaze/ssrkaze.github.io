<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript中的闭包</title>
    <url>/posts/2061875283/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript 中的闭包是所有学习这门语言的人绕不开的话题。虽然网上已经有很多解说的文章了，但是我还是觉得有必要写写自己的认知。这不仅是对自己学习的一个总结，也是一个梳理知识的机会。事实上，这篇文章在发出去前已经经历了许多次的修改，也确实帮助我把之前忽视的一些细节重新地捡起来了。</p>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><p>闭包一直缺乏一个官方的定义，这也是争议点比较大的部分。在不同的地方，对闭包有着不同的定义。</p>
<p>比如 MDN 上是这样描述的：</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。</p>
</blockquote>
<p>比如在《JavaScript 高级程序设计（第 4 版）》上是这样描述的：</p>
<blockquote>
<p>闭包指的是那些引用了另一个函数作用域中变量的函数。</p>
</blockquote>
<p>又或是在《JavaScript 权威指南（第 6 版）》里：</p>
<blockquote>
<p>从技术角度讲，所有的 JavaScript 函数都是闭包。</p>
</blockquote>
<p>在我看来，这些定义都没错，本质上来说，他们都是指向同一个东西。我认为，闭包是词法环境的副产物。要弄清楚闭包，就需要把词法环境先搞明白。</p>
<h1 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h1><p>ES6 中的原文摘录如下，可以跳过不看：</p>
<blockquote>
<p>A <em>Lexical Environment</em> is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an Environment Record and a possibly null reference to an <em>outer</em> Lexical Environment.</p>
<p>An Environment Record records the identifier bindings that are created within the scope of its associated Lexical Environment</p>
</blockquote>
<p>简单来讲，词法环境就是一种规范类型（也就是仅用于在规范中描述一些属性变量的特性），用来定义在嵌套结构中变量与函数的行为。在词法环境中包含了当前的环境记录和指向外部词法环境的引用，而每个词法环境的环境记录中记载了所有定义在该作用域中的变量。</p>
<p>由于外部引用的存在，使得解析器可以沿着外部引用由内向外地查找记载于各层环境记录中的变量。这个过程是单向而不可逆的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，函数嵌套在全局中，所以函数的外部词法环境引用指向了全局。在函数中，既可以找到定义在函数环境中的变量<code>b</code>，也可以沿着引用找到定义在全局环境中<code>a</code>。而对于全局环境而言，不可能逆向寻找到函数中的变量<code>b</code>。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的创建到运行过程复杂而且琐碎，这里只做简单说明。</p>
<p>每次函数的声明的时候都会创建一个新的词法环境。它的外部引用指向当前外部的词法环境，并将其写入函数的存储空间，或者说，写入函数对象的<code>[[Environment]]</code>内置接口(在 ES5 中是<code>[[Scope]]</code>)。这一点在 ES6 中写得明明白白:</p>
<blockquote>
<p>Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.</p>
<p>通常一个词法环境与一些像是函数声明……这样的结构有关。每次这些代码被执行的时候，词法环境都会被创建。</p>
</blockquote>
<p>通过代码来演示一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>此时，虽然<code>fun</code>函数是在<code>out</code>函数中被执行，但是它的<code>a</code>变量仍然指向了全局中的<code>a</code>，而不是<code>out</code>函数中的<code>a</code>。这是因为函数的词法环境是在声明之初就被创建好了，其外部引用指向全局环境，并被写入函数的存储空间中。</p>
<p>然后，在函数执行的时候，会开辟一个新的执行空间，并将函数声明时创建的数据存入这个执行空间。这一点通过代码来说明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">fun(); <span class="comment">// 1</span></span><br><span class="line">fun(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这里两次执行<code>fun()</code>语句都成功完成了。这说明了两件事：第一，存储空间和执行空间不同，存储的时候不发生执行。第二，每次函数执行的时候都会开辟新的空间。这两件事很好理解：因为<code>let</code>不允许重复声明。换一种角度想想也是很好理解的：数据是存储在硬盘上，但是运算是发生在内存中。</p>
<p>值得一提的是，外部引用指向的不是存储数据的地址，而是执行环境的地址。因为需要从外部的环境记录中获取变量，而上面说了存储时不执行，存储空间里的环境记录中自然也就没有所需的变量。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>现在，终于可以来讲讲闭包了。</p>
<p>一个简单而经典的闭包是这样子的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = counter();</span><br><span class="line">b(); <span class="comment">// 2</span></span><br><span class="line">b(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>现在运用上面的知识来解释闭包。JavaScript 程序在运行，必然会有一个执行的空间。<code>counter</code>函数定义在全局中，此时它的外部引用指向全局的执行空间，并写入存储中。然后<code>b</code>调用了<code>counter</code>函数。<code>counter</code>函数创建了一个全新的执行空间，将存储的数据复制进这片空间，并开始执行函数体：定义了<code>a</code>变量，并声明了一个匿名函数。匿名函数定义在这片执行空间中，自然将这片空间作为它的外部引用，写入存储中。最后再把匿名函数的存储地址交给变量<code>b</code>，完成这次的执行任务。</p>
<p>现在再来看看两次执行。第一次执行，函数开辟新的空间，复制数据，执行。发现没有<code>a</code>变量，于是沿着外部引用找到匿名函数声明时的执行空间，修改并读取值。第二次执行，又是相同的流程，再回到声明时的执行空间，修改并读取值。</p>
<p>这下就很清楚了。虽然两次执行所在的空间是不同的，但是它们的外部引用是一致的，只要数据是存储在外部引用所指向的空间，它们就能共享数据。</p>
<p>那么再来一点点小进阶：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = counter();</span><br><span class="line"><span class="keyword">let</span> c = counter();</span><br><span class="line">b(); <span class="comment">// 2</span></span><br><span class="line">b(); <span class="comment">// 3</span></span><br><span class="line">c(); <span class="comment">// 2</span></span><br><span class="line">b(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>可以看到，变量<code>b</code>和<code>c</code>互不干扰。这也很好理解：<code>c</code>又去执行了一次<code>counter</code>函数，于是创造了一片新的<code>counter</code>函数执行空间，在这片空间又放进了存储数据。之前说过，储存不执行，自然一切还是从新开始。声明于这个空间的匿名函数在每次执行的时候，共享的是这片空间中的数据，与<code>b</code>那片空间自然互不干扰。</p>
<p>现在再来看看这两句话</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。</p>
<p>闭包指的是那些引用了另一个函数作用域中变量的函数。</p>
</blockquote>
<p>是不是都是对闭包的不同描述？</p>
<h1 id="无处不在的闭包"><a href="#无处不在的闭包" class="headerlink" title="无处不在的闭包"></a>无处不在的闭包</h1><p>闭包看起来陌生，其实无处不在。举例而言，被引入的 JS 文件形成了一个闭包。试看如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>)(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">let</span> PENDDING = <span class="string">&quot;pedding&quot;</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">function</span> <span class="built_in">Promise</span>()&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">window</span>.<span class="built_in">Promise</span> = <span class="built_in">Promise</span>;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>))(<span class="params"><span class="built_in">window</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>这是手写 Promise 的一个片段。我们可以发现，其内部的<code>PENDDING</code>变量，可以一直访问。而<code>window.Promise</code>实质，就是返回一个函数到全局对象中，与<code>return</code>行为无异。这就是一个闭包。</p>
<p>再大胆点，我们可以说整个 JS 就是一个大闭包。它在执行的时候，将许多的方法暴露出来。我们可以在控制台中随时使用这些方法，并访问定义在全局中的变量。</p>
<p>所以权威指南才会写道：</p>
<blockquote>
<p>从技术角度讲，所有的 JavaScript 函数都是闭包。</p>
</blockquote>
]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>散装自译ECMA262(ES5)</title>
    <url>/posts/1562462180/</url>
    <content><![CDATA[<h1 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h1><ol>
<li>本文档是 <a href="https://ssrkaze.github.io/posts/763779422/">散装自译ECMA262(中英对照)</a> 中 ES5 相关部分的整合，只保留中文，只为优化阅读体验，内容结构完全一致。</li>
<li>可能还是会比较难理解，请多多担待。</li>
</ol>
<a id="more"></a>

<h1 id="词法环境和环境记录"><a href="#词法环境和环境记录" class="headerlink" title="词法环境和环境记录"></a>词法环境和环境记录</h1><h2 id="8-1-1-词法环境和环境记录规范类型"><a href="#8-1-1-词法环境和环境记录规范类型" class="headerlink" title="8.1.1 词法环境和环境记录规范类型"></a>8.1.1 词法环境和环境记录规范类型</h2><p><strong>词法环境</strong>和<strong>环境记录</strong>类型被用于解释在嵌套函数和块中名称解析的行为。这些基于词法环境和环境记录的类型和操作在<a href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">条文 10</a>中被定义。</p>
<h2 id="10-2-词法环境"><a href="#10-2-词法环境" class="headerlink" title="10.2 词法环境"></a>10.2 词法环境</h2><p><strong>词法环境</strong>是一种用于定义特定变量和基于 ECMAScript 代码词法嵌套结构的函数与标识符之间的联系的规范类型。<strong>词法环境</strong>由一个<strong>环境记录</strong>和一个可能为空的<strong>外部词法环境引用</strong>组成。通常一个<strong>词法环境</strong>与一些像是函数声明、With 语句，或者在一个 Try 语句中的 Catch 从句这样特殊的 ECMAScript 代码句法结构有关。每次这些代码被执行的时候，词法环境都会被创建。</p>
<p><strong>环境记录</strong>记载了在与标识符相关的词法环境作用域中被创建的标识符绑定。</p>
<p><strong>外部环境引用</strong>被用于塑造词法环境值的逻辑嵌套。一个（内部）词法嵌套的外部引用是对逻辑上包含了内部词法环境的一个词法环境的引用。<strong>外部词法环境</strong>当然也可能拥有它的外部词法环境。一个词法环境可能会被充当为多个内部词法环境的外部环境。例如，一个函数声明包含了两个嵌套的函数声明，那么每个被嵌套的函数的词法环境将会以当前外围执行的函数的词法环境作为它们的外部词法环境。</p>
<p>词法环境和环境记录值只是纯粹的规范机制，不需要与任何特定的 ECMAScript 实现保持一致。它不可能被一个 ECMAScript 程序直接访问或者操控。</p>
<h2 id="10-2-1-环境记录"><a href="#10-2-1-环境记录" class="headerlink" title="10.2.1 环境记录"></a>10.2.1 环境记录</h2><p>在本规范中有两种环境记录的值：<strong>声明环境记录</strong>和<strong>对象环境记录</strong>。<strong>声明环境记录</strong>被用于定义像是函数声明，变量定义和 Catch 从句这些直接与绑定了 ECMAScript 语言值的标识符有关联的 ECMAScript 语言句法元素的效果。<strong>对象环境记录</strong>被用于定义像是 Program 和 With 语句这样与绑定了一些对象的属性的标识符有关联的 ECMAScript 元素的效果。</p>
<p>出于规范的需求，<strong>环境记录</strong>的值可以被认为是简单的面向对象层次中的一个包含了<strong>声明环境记录</strong>和<strong>对象环境记录</strong>这两个具体子类的抽象类。抽象类中包含了定义在表 17 中的抽象规范方法。每个具体的子类的抽象方法都有具体而清晰的算法。</p>
<h2 id="10-2-1-1-声明环境记录"><a href="#10-2-1-1-声明环境记录" class="headerlink" title="10.2.1.1 声明环境记录"></a>10.2.1.1 声明环境记录</h2><p>每个<strong>声明环境记录</strong>都与一个包含了变量和/或函数声明的 ECMAScript 程序作用域相关。<strong>声明环境记录</strong>绑定了一系列在它作用域内被声明定义的标识符。</p>
<p>除了所有环境记录都支持的可变绑定之外，<strong>声明环境记录</strong>还允许<strong>不可变绑定</strong>。<strong>不可变绑定</strong>是当标识符和值之间的关系被建立时可能不会被立即修改。创建和初始化<strong>不可变绑定</strong>是截然不同的步骤，所以这种绑定是有可能是处在初始化或者未初始化状态下的。<strong>声明环境记录</strong>除了支持环境记录的抽象规范方法，还支持表 18 中的方法。</p>
<p><strong>声明环境记录</strong>的具体规范方法的行为由以下算法定义。</p>
<h2 id="10-2-1-2-对象环境记录"><a href="#10-2-1-2-对象环境记录" class="headerlink" title="10.2.1.2 对象环境记录"></a>10.2.1.2 对象环境记录</h2><p>每个<strong>对象环境记录</strong>都与一个被称为绑定对象的对象相关联。<strong>对象环境记录</strong>把它的绑定对象的属性名与一系列直接对应的标识符名称一一绑定。不符合<code>IdentifierName</code>的属性名不会包含在该系列中。自有的属性和继承的属性会无视<code>[[Enumerable]]</code>属性的设置包含在该系列中。因为对象上的属性可以动态地被添加或者被删除，<strong>对象环境记录</strong>绑定的这一系列标识符可能会因为有着添加或者删除属性的任意操作的副作用而被隐蔽地修改。任何作为上述副作用的结果而被创建的绑定都会被视为可变绑定，即使这个属性的<code>Writable</code>属性值为<code>false</code>。在对象环境记录中不存在不可变的绑定。</p>
<p><strong>对象环境记录</strong>可以被配置为在被函数调用时提供它们的绑定对象作为一个隐式的<code>this</code>的值。这个能力被用于明确包含了绑定的 With 语句的行为。这个能力被每个对象环境记录中的一个名为<code>provideThis</code>的布尔值控制。默认情况下，这个值是<code>false</code>。</p>
<p>对象环境记录的具体规范方法行为被以下的算法定义。</p>
<h2 id="10-2-3-全局环境"><a href="#10-2-3-全局环境" class="headerlink" title="10.2.3 全局环境"></a>10.2.3 全局环境</h2><p><strong>全局环境</strong>是一个在任意的 ECMAScript 代码被执行前就创建了的特殊词法环境。全局环境的词法环境记录是一个绑定了全局对象的对象环境记录。全局环境的外部环境引用为<code>null</code>。</p>
<p>当 ECMAScript 代码被执行后，附加的属性可能会被添加到全局对象，并且原始的属性可能会被修改。</p>
]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>散装自译ECMA262(ES6)</title>
    <url>/posts/1980503079/</url>
    <content><![CDATA[<h1 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h1><ol>
<li>本文档是 <a href="https://ssrkaze.github.io/posts/763779422/">散装自译ECMA262(中英对照)</a> 中 ES6 相关部分的整合，只保留中文，只为优化阅读体验，内容结构完全一致。</li>
<li>可能还是会比较难理解，请多多担待。</li>
</ol>
<a id="more"></a>

<h1 id="词法环境和环境记录"><a href="#词法环境和环境记录" class="headerlink" title="词法环境和环境记录"></a>词法环境和环境记录</h1><h2 id="6-2-5-词法环境和环境记录规范类型"><a href="#6-2-5-词法环境和环境记录规范类型" class="headerlink" title="6.2.5 词法环境和环境记录规范类型"></a>6.2.5 词法环境和环境记录规范类型</h2><p><strong>词法环境</strong>和<strong>环境记录</strong>类型被用于解释在嵌套函数和块中名称解析的行为。这些基于词法环境和环境记录的类型和操作在<a href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">8.1</a>中被定义。</p>
<h2 id="8-1-词法环境"><a href="#8-1-词法环境" class="headerlink" title="8.1 词法环境"></a>8.1 词法环境</h2><p><strong>词法环境</strong>是一种用于定义特定变量和基于 ECMAScript 代码词法嵌套结构的函数与标识符之间的联系的规范类型。<strong>词法环境</strong>由一个<strong>环境记录</strong>和一个可能为<code>null</code>的<strong>外部词法环境引用</strong>组成。通常一个<strong>词法环境</strong>与一些像是函数声明、Block 语句，或者在一个 Try 语句中的 Catch 从句这样特殊的 ECMAScript 代码句法结构有关。每次这些代码被执行的时候，词法环境都会被创建。</p>
<p><strong>环境记录</strong>记载了在与标识符相关的词法环境作用域中被创建的标识符绑定。它被描述为词法环境的环境记录。</p>
<p><strong>外部环境引用</strong>被用于塑造词法环境值的逻辑嵌套。一个（内部）词法嵌套的外部引用是对逻辑上包含了内部词法环境的一个词法环境的引用。<strong>外部词法环境</strong>当然也可能拥有它的外部词法环境。一个词法环境可能会被充当为多个内部词法环境的外部环境。例如，一个函数声明包含了两个嵌套的函数声明，那么每个被嵌套的函数的词法环境将会以当前外围执行的函数的词法环境作为它们的外部词法环境。</p>
<p><strong>全局环境</strong>是一个没有外部环境的词法环境。<strong>全局环境</strong>的外部环境引用为<code>null</code>。<strong>全局环境</strong>的环境记录可能会被预先填充标识符绑定并且会包含一个与之相关的、具有提供一些全局环境标识符绑定属性的全局对象。这个全局对象是全局环境<code>this</code>绑定的值。当 ECMAScript 代码被执行后，附加的属性可能会被添加到全局对象，并且原始的属性可能会被修改。</p>
<p><strong>模块环境</strong>是一个包含了模块中顶级声明绑定的词法环境。它还包含了模块明确导入的绑定。<strong>模块环境</strong>的外部环境是全局环境。</p>
<p><strong>函数环境</strong>是一个与 ECMAScript 函数对象调用相一致的词法环境。<strong>函数环境</strong>可能会创建一个新的<code>this</code>绑定。函数环境还会捕获必要的状态来满足<code>super</code>调用。</p>
<p>词法环境和环境记录值只是纯粹的规范机制，不需要与任何特定的 ECMAScript 实现保持一致。它不可能被一个 ECMAScript 程序直接访问或者操控。</p>
<h2 id="8-1-1-环境记录"><a href="#8-1-1-环境记录" class="headerlink" title="8.1.1 环境记录"></a>8.1.1 环境记录</h2><p>在本规范中有两种基本环境记录的值：<strong>声明环境记录</strong>和<strong>对象环境记录</strong>。<strong>声明环境记录</strong>被用于定义像是函数声明，变量定义和 Catch 从句这些直接与绑定了 ECMAScript 语言值的标识符有关联的 ECMAScript 语言句法元素的效果。<strong>对象环境记录</strong>被用于定义像是 With 语句这样与绑定了一些对象的属性的标识符有关联的 ECMAScript 元素的效果。<strong>全局环境记录</strong>和<strong>函数环境记录</strong>被专门用于脚本的全局声明和函数中的顶级声明。</p>
<p>出于规范的需求，<strong>环境记录</strong>的值是记录规范类型的值并且可以被认为是简单的面向对象层次中的一个包含了<strong>声明环境记录</strong>、<strong>对象环境记录</strong>和<strong>全局环境记录</strong>这三个具体子类的抽象类。<strong>函数环境记录</strong>和<strong>模块环境记录</strong>是<strong>声明环境记录</strong>的子类。抽象类中包含了定义在表 15 中的抽象规范方法。每个具体的子类的抽象方法都有具体而清晰的算法。</p>
<h2 id="8-1-1-1-声明环境记录"><a href="#8-1-1-1-声明环境记录" class="headerlink" title="8.1.1.1 声明环境记录"></a>8.1.1.1 声明环境记录</h2><p>每个<strong>声明环境记录</strong>都与一个包含了变量、constant、let、class、module、import 和/或函数声明的 ECMAScript 程序作用域相关。<strong>声明环境记录</strong>绑定了一系列在它作用域内被声明定义的标识符。</p>
<p><strong>声明环境记录</strong>的具体规范方法的行为由以下算法定义。</p>
<h2 id="8-1-1-2-对象环境记录"><a href="#8-1-1-2-对象环境记录" class="headerlink" title="8.1.1.2 对象环境记录"></a>8.1.1.2 对象环境记录</h2><p>每个<strong>对象环境记录</strong>都与一个被称为绑定对象的对象相关联。<strong>对象环境记录</strong>把它的绑定对象的属性名与一系列直接对应的字符串标识符名称一一绑定。不符合<code>IdentifierName</code>的字符串属性名不会包含在该系列中。自有的属性和继承的属性会无视<code>[[Enumerable]]</code>属性的设置包含在该系列中。因为对象上的属性可以动态地被添加或者被删除，<strong>对象环境记录</strong>绑定的这一系列标识符可能会因为有着添加或者删除属性的任意操作的副作用而被隐蔽地修改。任何作为上述副作用的结果而被创建的绑定都会被视为可变绑定，即使这个属性的<code>Writable</code>属性值为<code>false</code>。在<strong>对象环境记录</strong>中不存在不可变的绑定。</p>
<p>为<code>With</code>语句创建的<strong>对象环境记录</strong>在被函数调用时可以提供它们的绑定对象作为隐式的<code>this</code>值。这个能力被每个<strong>对象环境记录</strong>中的一个名为<code>withEnvironment</code>的布尔值控制。默认情况下，这个值是<code>false</code>。</p>
<p><strong>对象环境记录</strong>的具体规范方法行为被以下的算法定义。</p>
<h2 id="8-1-1-3-函数环境记录"><a href="#8-1-1-3-函数环境记录" class="headerlink" title="8.1.1.3 函数环境记录"></a>8.1.1.3 函数环境记录</h2><p><strong>函数环境记录</strong>是用于代表函数顶级作用域的一种<strong>声明环境记录</strong>，并且当这个函数不是箭头函数时，提供了一个<code>this</code>的绑定。当一个函数不是箭头函数且引用了<code>super</code>时，它的<strong>函数环境记录</strong>还会包含用于执行函数内调用<code>super</code>方法的状态。</p>
<p><strong>函数环境记录</strong>还拥有表 16 中列出的附加状态字段。</p>
<p><strong>函数环境记录</strong>支持表 15 列出的所有<strong>声明环境记录</strong>方法并且与除了<code>HasThisBinding</code>和<code>HasSuperBinding</code>之外的所有方法共享同样的标准。另外，<strong>函数环境记录</strong>还支持表 17 中的方法。</p>
<p><strong>函数环境记录</strong>的附加具体规范方法行为被以下的算法定义。</p>
<h2 id="8-1-1-4-全局环境记录"><a href="#8-1-1-4-全局环境记录" class="headerlink" title="8.1.1.4 全局环境记录"></a>8.1.1.4 全局环境记录</h2><p><strong>全局环境记录</strong>被用于代表所有执行在通用领域的 ECMAScript 元素共享的最外层作用域。<strong>全局环境记录</strong>提供了一个内置的全局、全局对象的属性和在脚本中出现的所有顶级声明的绑定。</p>
<p><strong>全局环境记录</strong>虽然逻辑上是一种单一的记录，但它被明确地概括为一个<strong>对象环境记录</strong>和<strong>声明环境记录</strong>的混合。<strong>对象环境记录</strong>在全局对象的相关领域将其作为基础对象。这个全局对象是全局环境记录的<code>GetThisBinding</code>这一具体方法的返回值。<strong>全局环境记录</strong>中的<strong>对象环境记录</strong>部分包含了所有内置的全局（从句 18）和所有在全局代码中被函数声明、生成器声明或者变量语句引入的绑定。其他所有在全局代码中的 ECMAScript 声明的绑定被包含在<strong>全局环境记录</strong>中的<strong>声明环境记录</strong>部分。</p>
<p>属性可能会被直接在全局对象上创建。因此，<strong>全局环境记录</strong>中的<strong>对象环境记录</strong>部分可能同时包含被函数声明、生成器声明和变量声明明确建的绑定和作为全局对象的属性被隐式创建的绑定。为了明确哪些绑定是使用声明被明确创建的，<strong>全局环境记录</strong>会使用它<code>CreateGlobalVarBindings</code>和<code>CreateGlobalFunctionBindings</code>这两个具体的方法来维护一个名称绑定列表。</p>
<p><strong>全局环境记录</strong>拥有表 18 列出的附加字段和表 19 中附加的方法。</p>
<h2 id="8-1-1-5-模块环境记录"><a href="#8-1-1-5-模块环境记录" class="headerlink" title="8.1.1.5 模块环境记录"></a>8.1.1.5 模块环境记录</h2><p><strong>模块环境记录</strong>是一种用于代表 ECMAScript 模块外部作用域的的<strong>声明环境记录</strong>。除了普通的可变和不可变绑定，<strong>模块环境记录</strong>还允许不可变导入绑定。不可变导入绑定是一种提供间接访问在另一个环境记录中的目标绑定的绑定。</p>
<p><strong>模块环境记录</strong>支持表 15 列出的所有<strong>声明环境记录</strong>方法并且与除了<code>GetBindingValue</code>、<code>DeleteBinding</code>、<code>HasThisBinding</code>和<code>GetThisBinding</code>之外的所有方法共享同样的标准。另外，<strong>函数环境记录</strong>还支持表 20 中的方法。</p>
<p><strong>模块环境记录</strong>的附加具体规范方法行为被以下的算法定义。</p>
]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>散装自译ECMA262(中英对照)</title>
    <url>/posts/763779422/</url>
    <content><![CDATA[<h1 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h1><ol>
<li>翻译自 <a href="https://www.ecma-international.org/ecma-262/5.1/index.html">Standard ECMA-262, 5.1 Edition, ECMAScript® Language Specification</a></li>
<li>翻译自 <a href="https://www.ecma-international.org/ecma-262/6.0/index.html">Standard ECMA-262, 6th Edition, ECMAScript® 2015 Language Specification</a></li>
<li>部分术语的翻译参考自 <a href="https://www.termonline.cn/">术语在线</a>、<a href="https://github.com/docschina/ecma262/issues/59">ECMAScript® 语言规范中文翻译工作中英词汇对照表</a>，部分术语翻译出自理解，仅供自娱自乐</li>
<li>之所以翻译两份标准，是因为 ES6 相对 ES5 有着巨大的变化。现行的许多资料既有 ES5 的。也有 ES6 的，为了对照方便，就一起翻译了。</li>
<li>由于原文本身晦涩难明，所以译文也不可避免地出现了一些长难句。后续每一阶段的结束，我都会撰写一篇文章用于梳理。</li>
<li>另有两份文档分别是本文档中文部分针对 ES5、ES6 的提取，可能会对阅读理解有所帮助。</li>
</ol>
<a id="more"></a>

<h1 id="词法环境和环境记录"><a href="#词法环境和环境记录" class="headerlink" title="词法环境和环境记录"></a>词法环境和环境记录</h1><h2 id="词法环境和环境记录规范类型"><a href="#词法环境和环境记录规范类型" class="headerlink" title="词法环境和环境记录规范类型"></a>词法环境和环境记录规范类型</h2><ol>
<li><p><strong><em>5.1 Edition, 8.11 The Lexical Environment and Environment Record Specification Types</em></strong></p>
<blockquote>
<p>The <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2">Lexical Environment</a> and <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">Environment Record</a> types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10">Clause 10</a>.</p>
</blockquote>
<p> <strong>词法环境</strong>和<strong>环境记录</strong>类型被用于解释在嵌套函数和块中名称解析的行为。这些基于词法环境和环境记录的类型和操作在<a href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87">条文 10</a>中被定义。</p>
</li>
<li><p><strong><em>6 Edition, 6.2.5 The Lexical Environment and Environment Record Specification Types</em></strong></p>
</li>
</ol>
<blockquote>
<p>The <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-lexical-environments">Lexical Environment</a> and <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-lexical-environments">8.1</a>.</p>
</blockquote>
<p>同上，略。</p>
<h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><ol>
<li><p><strong><em>5.1 Edition, 10.2 Lexical Environments</em></strong></p>
<blockquote>
<p>A <em>Lexical Environment</em> is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code.</p>
</blockquote>
<p> <strong>词法环境</strong>是一种用于定义特定变量和基于 ECMAScript 代码词法嵌套结构的函数与标识符之间的联系的规范类型。</p>
<blockquote>
<p>A Lexical Environment consists of an <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">Environment Record</a> and a possibly null reference to an <em>outer</em> Lexical Environment.</p>
</blockquote>
<p> <strong>词法环境</strong>由一个<strong>环境记录</strong>和一个可能为空的<strong>外部词法环境引用</strong>组成。</p>
<blockquote>
<p>Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a WithStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.</p>
</blockquote>
<p> 通常一个<strong>词法环境</strong>与一些像是函数声明、With 语句，或者在一个 Try 语句中的 Catch 从句这样特殊的 ECMAScript 代码句法结构有关。每次这些代码被执行的时候，词法环境都会被创建。</p>
<blockquote>
<p>An <em><a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">Environment Record</a></em> records the identifier bindings that are created within the scope of its associated Lexical Environment.</p>
</blockquote>
<p> <strong>环境记录</strong>记载了在与标识符相关的词法环境作用域中被创建的标识符绑定。</p>
<blockquote>
<p>The outer environment reference is used to model the logical nesting of Lexical Environment values.</p>
</blockquote>
<p> <strong>外部环境引用</strong>被用于塑造词法环境值的逻辑嵌套。</p>
<blockquote>
<p>The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment.</p>
</blockquote>
<p> 一个（内部）词法嵌套的外部引用是对逻辑上包含了内部词法环境的一个词法环境的引用。</p>
<blockquote>
<p>An outer Lexical Environment may, of course, have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments.</p>
</blockquote>
<p> <strong>外部词法环境</strong>当然也可能拥有它的外部词法环境。一个词法环境可能会被充当为多个内部词法环境的外部环境。</p>
<blockquote>
<p>For example, if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current execution of the surrounding function.</p>
</blockquote>
<p> 例如，一个函数声明包含了两个嵌套的函数声明，那么每个被嵌套的函数的词法环境将会以当前外围执行的函数的词法环境作为它们的外部词法环境。</p>
<blockquote>
<p>Lexical Environments and <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">Environment Record</a> values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation.It is impossible for an ECMAScript program to directly access or manipulate such values.</p>
</blockquote>
<p> 词法环境和环境记录值只是纯粹的规范机制，不需要与任何特定的 ECMAScript 实现保持一致。它不可能被一个 ECMAScript 程序直接访问或者操控。</p>
</li>
<li><p><strong><em>6 Edition, 8.1 Lexical Environments</em></strong></p>
<blockquote>
<p>A <em>Lexical Environment</em> is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> and a possibly null reference to an <em>outer</em> Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.</p>
</blockquote>
<p> (前略)……<strong>词法环境</strong>由一个<strong>环境记录</strong>和一个可能为<code>null</code>的<strong>外部词法环境引用</strong>组成。通常一个<strong>词法环境</strong>与一些像是函数声明、Block 语句，或者在一个 Try 语句中的 Catch 从句这样特殊的 ECMAScript 代码句法结构有关。</p>
<blockquote>
<p>An <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> records the identifier bindings that are created within the scope of its associated Lexical Environment. It is referred to as the Lexical Environment’s EnvironmentRecord.</p>
</blockquote>
<p> …它被描述为词法环境的环境记录。</p>
<blockquote>
<p>The outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current evaluation of the surrounding function.</p>
</blockquote>
<p> 同上，略。</p>
<blockquote>
<p>A <em>global environment</em> is a Lexical Environment which does not have an outer environment. The global environment’s outer environment reference is <strong>null</strong>.</p>
</blockquote>
<p> <strong>全局环境</strong>是一个没有外部环境的词法环境。<strong>全局环境</strong>的外部环境引用为<code>null</code>。</p>
<blockquote>
<p>A global environment’s EnvironmentRecord may be prepopulated with identifier bindings and includes an associated <em>global object</em> whose properties provide some of <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-global-environment-records">the global environment</a>’s identifier bindings.</p>
</blockquote>
<p> <strong>全局环境</strong>的环境记录可能会被预先填充标识符绑定并且会包含一个与之相关的、具有提供一些全局环境标识符绑定属性的全局对象。</p>
<blockquote>
<p>This global object is the value of a global environment’s <code>this</code> binding. As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.</p>
</blockquote>
<p> 这个全局对象是全局环境<code>this</code>绑定的值。当 ECMAScript 代码被执行后，附加的属性可能会被添加到全局对象，并且原始的属性可能会被修改。</p>
<blockquote>
<p>A <em>module environment</em> is a Lexical Environment that contains the bindings for the top level declarations of a Module. It also contains the bindings that are explicitly imported by the Module. The outer environment of a module environment is a global environment.</p>
</blockquote>
<p> <strong>模块环境</strong>是一个包含了模块中顶级声明绑定的词法环境。它还包含了模块明确导入的绑定。<strong>模块环境</strong>的外部环境是全局环境。</p>
<blockquote>
<p>A <em>function environment</em> is a Lexical Environment that corresponds to the invocation of an <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-function-objects">ECMAScript function object</a>. A function environment may establish a new <code>this</code> binding. A function environment also captures the state necessary to support <code>super</code> method invocations.</p>
</blockquote>
<p> <strong>函数环境</strong>是一个与 ECMAScript 函数对象调用相一致的词法环境。<strong>函数环境</strong>可能会创建一个新的<code>this</code>绑定。函数环境还会捕获必要的状态来满足<code>super</code>调用。</p>
<blockquote>
<p>Lexical Environments and <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.</p>
</blockquote>
<p> 同上。略。</p>
</li>
</ol>
<h2 id="环境记录"><a href="#环境记录" class="headerlink" title="环境记录"></a>环境记录</h2><ol>
<li><p><strong><em>5.1 Edition, 10.2.1 Environment Records</em></strong></p>
<blockquote>
<p>There are two kinds of Environment Record values used in this specification: <em>declarative environment records</em> and <em>object environment records</em>.</p>
</blockquote>
<p> 在本规范中有两种环境记录的值：<strong>声明环境记录</strong>和<strong>对象环境记录</strong>。</p>
<blockquote>
<p>Declarative Environment Records are used to define the effect of ECMAScript language syntactic elements such as FunctionDeclarations, VariableDeclarations, and Catch clauses that directly associate identifier bindings with <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-language-types">ECMAScript language values</a>.</p>
</blockquote>
<p> <strong>声明环境记录</strong>被用于定义像是函数声明，变量定义和 Catch 从句这些直接与绑定了 ECMAScript 语言值的标识符有关联的 ECMAScript 语言句法元素的效果。</p>
<blockquote>
<p>Object environment records are used to define the effect of ECMAScript elements such as Program and WithStatement that associate identifier bindings with the properties of some object.</p>
</blockquote>
<p> <strong>对象环境记录</strong>被用于定义像是 Program 和 With 语句这样与绑定了一些对象的属性的标识符有关联的 ECMAScript 元素的效果。</p>
<blockquote>
<p>For specification purposes Environment Record values can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract classwith two concrete subclasses, declarative environment record and object environment record.</p>
</blockquote>
<p> 出于规范的需求，<strong>环境记录</strong>的值可以被认为是简单的面向对象层次中的一个包含了<strong>声明环境记录</strong>和<strong>对象环境记录</strong>这两个具体子类的抽象类。</p>
<blockquote>
<p>The abstract class includes the abstract specification methods defined in Table 17. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.</p>
</blockquote>
<p> 抽象类中包含了定义在表 17 中的抽象规范方法。每个具体的子类的抽象方法都有具体而清晰的算法。</p>
</li>
<li><p><strong><em>6 Edition, 8.1.1 Environment Records</em></strong></p>
<blockquote>
<p>There are two primary kinds of Environment Record values used in this specification: <em>declarative Environment Records</em> and <em>object Environment Records</em>. Declarative Environment Records are used to define the effect of ECMAScript language syntactic elements such as FunctionDeclarations, VariableDeclarations, and Catch clauses that directly associate identifier bindings with <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-language-types">ECMAScript language values</a>. Object Environment Records are used to define the effect of ECMAScript elements such as WithStatement that associate identifier bindings with the properties of some object. <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-global-environment-records">Global Environment Records</a> and function Environment Records are specializations that are used for specifically for Script global declarations and for top-level declarations within functions.</p>
</blockquote>
<p> 在本规范中有两种基本环境记录的值：<strong>声明环境记录</strong>和<strong>对象环境记录</strong>。……<strong>对象环境记录</strong>被用于定义像是 With 语句这样与绑定了一些对象的属性的标识符有关联的 ECMAScript 元素的效果。<strong>全局环境记录</strong>和<strong>函数环境记录</strong>被专门用于脚本的全局声明和函数中的顶级声明。</p>
<blockquote>
<p>For specification purposes Environment Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with three concrete subclasses, declarative Environment Record, object Environment Record, and global Environment Record. <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-function-environment-records">Function Environment Records</a> and module Environment Records are subclasses of declarative Environment Record. The abstract class includes the abstract specification methods defined in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#table-15">Table 15</a>. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.</p>
</blockquote>
<p> 出于规范的需求，<strong>环境记录</strong>的值是记录规范类型的值并且可以被认为是简单的面向对象层次中的一个包含了<strong>声明环境记录</strong>、<strong>对象环境记录</strong>和<strong>全局环境记录</strong>这三个具体子类的抽象类。<strong>函数环境记录</strong>和<strong>模块环境记录</strong>是<strong>声明环境记录</strong>的子类。…….</p>
</li>
</ol>
<h2 id="对象环境记录"><a href="#对象环境记录" class="headerlink" title="对象环境记录"></a>对象环境记录</h2><ol>
<li><p><strong><em>5.1 Edition, 10.2.1.2 Object Environment Records</em></strong></p>
<blockquote>
<p>Each <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">object environment record</a> is associated with an object called its <em>binding object</em>.An <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">object environment record</a> binds the set of identifier names that directly correspond to the property names of its binding object.</p>
</blockquote>
<p> 每个<strong>对象环境记录</strong>都与一个被称为绑定对象的对象相关联。<strong>对象环境记录</strong>把它的绑定对象的属性名与一系列直接对应的标识符名称一一绑定。</p>
<blockquote>
<p>Property names that are not an IdentifierName are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]] attribute.</p>
</blockquote>
<p> 不符合<code>IdentifierName</code>的属性名不会包含在该系列中。自有的属性和继承的属性会无视<code>[[Enumerable]]</code>属性的设置包含在该系列中。</p>
<blockquote>
<p>Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">object environment record</a> may potentially change as a side-effect of any operation that adds or deletes properties.</p>
</blockquote>
<p> 因为对象上的属性可以动态地被添加或者被删除，<strong>对象环境记录</strong>绑定的这一系列标识符可能会因为有着添加或者删除属性的任意操作的副作用而被隐蔽地修改。</p>
<blockquote>
<p>Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property has the value <strong>false</strong>. Immutable bindings do not exist for object environment records.</p>
</blockquote>
<p> 任何作为上述副作用的结果而被创建的绑定都会被视为可变绑定，即使这个属性的<code>Writable</code>属性值为<code>false</code>。在对象环境记录中不存在不可变的绑定。</p>
<blockquote>
<p>Object environment records can be configured to provide their binding object as an implicit this value for use in function calls.</p>
</blockquote>
<p> <strong>对象环境记录</strong>可以被配置为在被函数调用时提供它们的绑定对象作为一个隐式的<code>this</code>的值。</p>
<blockquote>
<p>This capability is used to specify the behaviour of With Statement (<a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-12.10">12.10</a>) induced bindings. The capability is controlled by a provideThis Boolean value that is associated with each <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">object environment record</a>. By default, the value of provideThis is <strong>false</strong> for any <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">object environment record</a>.</p>
</blockquote>
<p> 这个能力被用于明确包含了绑定的 With 语句的行为。这个能力被每个对象环境记录中的一个名为<code>provideThis</code>的布尔值控制。默认情况下，这个值是<code>false</code>。。</p>
<blockquote>
<p>The behaviour of the concrete specification methods for Object Environment Records is defined by the following algorithms.</p>
</blockquote>
<p> <strong>对象环境记录</strong>的具体规范方法行为被以下的算法定义。</p>
</li>
<li><p><strong><em>6 Edition, 8.1.1.2 Object Environment Records</em></strong></p>
<blockquote>
<p>Each object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> is associated with an object called its <em>binding object</em>. An object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> binds the set of string identifier names that directly correspond to the property names of its binding object. Property keys that are not strings in the form of an IdentifierName are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their [[Enumerable]] attribute. Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> may potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property has the value <strong>false</strong>. Immutable bindings do not exist for object Environment Records.</p>
</blockquote>
<p> …每个<strong>对象环境记录</strong>都与一个被称为绑定对象的对象相关联。<strong>对象环境记录</strong>把它的绑定对象的属性名与一系列直接对应的字符串标识符名称一一绑定。不符合<code>IdentifierName</code>的字符串属性名不会包含在该系列中。</p>
<blockquote>
<p>Object Environment Records created for <code>with</code> statements (<a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-with-statement">13.11</a>) can provide their binding object as an implicit <strong>this</strong> value for use in function calls. The capability is controlled by a withEnvironment Boolean value that is associated with each object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a>. By default, the value of withEnvironment is <strong>false</strong> for any object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a>.</p>
</blockquote>
<p> 为<code>With</code>语句创建的<strong>对象环境记录</strong>在被函数调用时可以提供它们的绑定对象作为隐式的<code>this</code>值。这个能力被每个<strong>对象环境记录</strong>中的一个名为<code>withEnvironment</code>的布尔值控制。默认情况下，这个值是<code>false</code>。</p>
<blockquote>
<p>The behaviour of the concrete specification methods for object Environment Records is defined by the following algorithms.</p>
</blockquote>
<p> 同上，略。</p>
</li>
</ol>
<h2 id="声明环境记录"><a href="#声明环境记录" class="headerlink" title="声明环境记录"></a>声明环境记录</h2><ol>
<li><p><strong><em>5.1 Edition, 10.2.1.1 Declarative Environment Records</em></strong></p>
<blockquote>
<p>Each <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">declarative environment record</a> is associated with an ECMAScript program scope containing variable and/or function declarations. A <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">declarative environment record</a> binds the set of identifiers defined by the declarations contained within its scope.</p>
</blockquote>
<p> 每个<strong>声明环境记录</strong>都与一个包含了变量和/或函数声明的 ECMAScript 程序作用域相关。<strong>声明环境记录</strong>绑定了一系列在它作用域内被声明定义的标识符。</p>
<blockquote>
<p>In addition to the mutable bindings supported by all Environment Records, declarative environment records also provide for immutable bindings. An immutable binding is one where the association between an identifier and a value may not be modified once it has been established.</p>
</blockquote>
<p> 除了所有环境记录都支持的可变绑定之外，<strong>声明环境记录</strong>还允许<strong>不可变绑定</strong>。<strong>不可变绑定</strong>是当标识符和值之间的关系被建立时可能不会被立即修改。</p>
<blockquote>
<p>Creation and initialisation of immutable binding are distinct steps so it is possible for such bindings to exist in either an initialised or uninitialised state. Declarative environment records support the methods listed in Table 18 in addition to the Environment Record abstract specification methods:</p>
</blockquote>
<p> 创建和初始化<strong>不可变绑定</strong>是截然不同的步骤，所以这种绑定是有可能是处在初始化或者未初始化状态下的。<strong>声明环境记录</strong>除了支持环境记录的抽象规范方法，还支持表 18 中的方法。</p>
<blockquote>
<p>The behaviour of the concrete specification methods for Declarative Environment Records is defined by the following algorithms</p>
</blockquote>
<p> <strong>声明环境记录</strong>的具体规范方法的行为由以下算法定义。</p>
</li>
<li><p><strong><em>6 Edition, 8.1.1.1 Declarative Environment Records</em></strong></p>
<blockquote>
<p>Each declarative <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> is associated with an ECMAScript program scope containing variable, constant, let, class, module, import, and/or function declarations. A declarative <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> binds the set of identifiers defined by the declarations contained within its scope.</p>
</blockquote>
<p> 每个<strong>声明环境记录</strong>都与一个包含了变量、constant、let、class、module、important 和/或函数声明的 ECMAScript 程序作用域相关。<strong>声明环境记录</strong>绑定了一系列在它作用域内被声明定义的标识符。</p>
<blockquote>
<p>The behaviour of the concrete specification methods for declarative Environment Records is defined by the following algorithms.</p>
</blockquote>
<p> 同上。略。</p>
</li>
</ol>
<h2 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h2><ol>
<li><p><strong><em>5.1 Edition, 10.2.3 The Global Environment</em></strong></p>
<blockquote>
<p>The <em>global environment</em> is a unique <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2">Lexical Environment</a> which is created before any ECMAScript code is executed. The global environment’s <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">Environment Record</a> is an <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2.1">object environment record</a> whose binding object is the global object (<a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-15.1">15.1</a>). The global environment’s <a href="https://www.ecma-international.org/ecma-262/5.1/index.html#sec-10.2">outer environment reference</a> is <strong>null</strong>.</p>
</blockquote>
<p> <strong>全局环境</strong>是一个在任意的 ECMAScript 代码被执行前就创建了的特殊词法环境。全局环境的词法环境记录是一个绑定了全局对象的对象环境记录。全局环境的外部环境引用为<code>null</code>。</p>
<blockquote>
<p>As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.</p>
</blockquote>
<p> 当 ECMAScript 代码被执行后，附加的属性可能会被添加到全局对象，并且原始的属性可能会被修改。</p>
</li>
<li><p><strong><em>6 Edition, 8.1 Lexical Environments</em></strong></p>
<blockquote>
<p>A <em>global environment</em> is a Lexical Environment which does not have an outer environment. The global environment’s outer environment reference is <strong>null</strong>. A global environment’s EnvironmentRecord may be prepopulated with identifier bindings and includes an associated <em>global object</em> whose properties provide some of <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-global-environment-records">the global environment</a>’s identifier bindings. This global object is the value of a global environment’s <code>this</code> binding. As ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.</p>
</blockquote>
<p> <strong>全局环境</strong>是一个没有外部环境的词法环境。<strong>全局环境</strong>的外部环境引用为<code>null</code>。<strong>全局环境</strong>的环境记录可能会被预先填充标识符绑定并且会包含一个与之相关的、具有提供一些全局环境标识符绑定属性的全局对象。这个全局对象是全局环境<code>this</code>绑定的值。当 ECMAScript 代码被执行后，附加的属性可能会被添加到全局对象，并且原始的属性可能会被修改。</p>
</li>
</ol>
<h2 id="函数环境记录"><a href="#函数环境记录" class="headerlink" title="函数环境记录"></a>函数环境记录</h2><ol>
<li><p>ES5.1 无相关描述</p>
</li>
<li><p><strong><em>6 Edition, 8.1.1.3 Function Environment Records</em></strong></p>
<blockquote>
<p>A function <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> is a declarative <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> that is used to represent the top-level scope of a function and, if the function is not an ArrowFunction, provides a <code>this</code> binding. If a function is not an ArrowFunction function and references <code>super</code>, its function <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> also contains the state that is used to perform <code>super</code> method invocations from within the function.</p>
</blockquote>
<p> 函数环境记录是用于代表函数顶级作用域的一种声明环境记录，并且当这个函数不是箭头函数时，提供了一个<code>this</code>的绑定。当一个函数不是箭头函数且引用了<code>super</code>时，它的函数环境记录还会包含用于执行函数内调用<code>super</code>方法的状态。</p>
<blockquote>
<p>Function Environment Records have the additional state fields listed in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#table-16">Table 16</a>.</p>
</blockquote>
<p> 函数环境记录还拥有表 16 中列出的附加状态字段。</p>
<blockquote>
<p>Function Environment Records support all of the declarative Environment Record methods listed in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#table-15">Table 15</a> and share the same specifications for all of those methods except for HasThisBinding and HasSuperBinding. In addition, function Environment Records support the methods listed in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#table-17">Table 17</a>:</p>
</blockquote>
<p> <strong>函数环境记录</strong>支持表 15 列出的所有<strong>声明环境记录</strong>方法并且与除了<code>HasThisBinding</code>和<code>HasSuperBinding</code>之外的所有方法共享同样的标准。另外，<strong>函数环境记录</strong>还支持表 17 中的方法。</p>
<blockquote>
<p>The behaviour of the additional concrete specification methods for function Environment Records is defined by the following algorithms:</p>
</blockquote>
<p> <strong>函数环境记录</strong>的附加具体规范方法行为被以下的算法定义。</p>
</li>
</ol>
<h2 id="全局环境记录"><a href="#全局环境记录" class="headerlink" title="全局环境记录"></a>全局环境记录</h2><ol>
<li><p>ES5.1 无相关描述</p>
</li>
<li><p><strong><em>6 Edition, 8.1.1.4 Global Environment Records</em></strong></p>
<blockquote>
<p>A global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> is used to represent the outer most scope that is shared by all of the ECMAScript Script elements that are processed in a common <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-code-realms">Realm</a> (<a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-code-realms">8.2</a>). A global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> provides the bindings for built-in globals (<a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-global-object">clause 18</a>), properties of the global object, and for all top-level declarations (<a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-static-semantics-toplevellexicallyscopeddeclarations">13.2.8</a>, <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-static-semantics-toplevelvarscopeddeclarations">13.2.10</a>) that occur within a Script.</p>
</blockquote>
<p> <strong>全局环境记录</strong>被用于代表所有执行在通用领域的 ECMAScript 元素共享的最外层作用域。<strong>全局环境记录</strong>提供了一个内置的全局、全局对象的属性和在脚本中出现的所有顶级声明的绑定。</p>
<blockquote>
<p>A global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> is logically a single record but it is specified as a composite encapsulating an object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> and a declarative <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a>.</p>
</blockquote>
<p> <strong>全局环境记录</strong>虽然逻辑上是一种单一的记录，但它被明确地概括为一个<strong>对象环境记录</strong>和<strong>声明环境记录</strong>的混合。</p>
<blockquote>
<p>The object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> has as its base object the global object of the associated <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-code-realms">Realm</a>.This global object is the value returned by the global Environment Record’s GetThisBinding concrete method.</p>
</blockquote>
<p> <strong>对象环境记录</strong>在全局对象的相关领域将其作为基础对象。这个全局对象是全局环境记录的<code>GetThisBinding</code>这一具体方法的返回值。</p>
<blockquote>
<p>The object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> component of a global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> contains the bindings for all built-in globals (<a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-global-object">clause 18</a>) and all bindings introduced by a <em>FunctionDeclaration</em>, <em>GeneratorDeclaration</em>, or VariableStatement contained in global code.</p>
</blockquote>
<p> <strong>全局环境记录</strong>中的<strong>对象环境记录</strong>部分包含了所有内置的全局（从句 18）和所有在全局代码中被函数声明、生成器声明或者变量语句引入的绑定。</p>
<blockquote>
<p>The bindings for all other ECMAScript declarations in global code are contained in the declarative <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> component of the global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a>.</p>
</blockquote>
<p> 其他所有在全局代码中的 ECMAScript 声明的绑定被包含在<strong>全局环境记录</strong>中的<strong>声明环境记录</strong>部分。</p>
<blockquote>
<p>Properties may be created directly on a global object. Hence, the object <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> component of a global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> may contain both bindings created explicitly by <em>FunctionDeclaration</em>, <em>GeneratorDeclaration</em>, or VariableDeclaration declarations and binding created implicitly as properties of the global object.</p>
</blockquote>
<p> 属性可能会被直接在全局对象上创建。因此，<strong>全局环境记录</strong>中的<strong>对象环境记录</strong>部分可能同时包含被函数声明、生成器声明和变量声明明确建的绑定和作为全局对象的属性被隐式创建的绑定。</p>
<blockquote>
<p>In order to identify which bindings were explicitly created using declarations, a global <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> maintains a list of the names bound using its CreateGlobalVarBindings and CreateGlobalFunctionBindings concrete methods.</p>
</blockquote>
<p> 为了明确哪些绑定是使用声明被明确创建的，<strong>全局环境记录</strong>会使用它<code>CreateGlobalVarBindings</code>和<code>CreateGlobalFunctionBindings</code>这两个具体的方法来维护一个名称绑定列表。</p>
<blockquote>
<p>Global Environment Records have the additional fields listed in Table 18 and the additional methods listed in Table 19.</p>
</blockquote>
<p> <strong>全局环境记录</strong>拥有表 18 列出的附加字段和表 19 中附加的方法。</p>
</li>
</ol>
<h2 id="模块环境记录"><a href="#模块环境记录" class="headerlink" title="模块环境记录"></a>模块环境记录</h2><ol>
<li><p>ES5.1 无相关描述</p>
</li>
<li><p><strong><em>6 Edition, 8.1.1.5 Module Environment Records</em></strong></p>
<blockquote>
<p>A module <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> is a declarative <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#sec-environment-records">Environment Record</a> that is used to represent the outer scope of an ECMAScript Module. In additional to normal mutable and immutable bindings, module Environment Records also provide immutable import bindings which are bindings that provide indirect access to a target binding that exists in another Environment Record.</p>
</blockquote>
<p> <strong>模块环境记录</strong>是一种用于代表 ECMAScript 模块外部作用域的的<strong>声明环境记录</strong>。除了普通的可变和不可变绑定，<strong>模块环境记录</strong>还允许不可变导入绑定。不可变导入绑定是一种提供间接访问在另一个环境记录中的目标绑定的绑定。</p>
<blockquote>
<p>Module Environment Records support all of the declarative Environment Record methods listed in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#table-15">Table 15</a> and share the same specifications for all of those methods except for GetBindingValue, DeleteBinding, HasThisBinding and GetThisBinding. In addition, module Environment Records support the methods listed in <a href="https://www.ecma-international.org/ecma-262/6.0/index.html#table-20">Table 20</a>:</p>
</blockquote>
<p> <strong>模块环境记录</strong>支持表 15 列出的所有<strong>声明环境记录</strong>方法并且与除了<code>GetBindingValue</code>、<code>DeleteBinding</code>、<code>HasThisBinding</code>和<code>GetThisBinding</code>之外的所有方法共享同样的标准。另外，<strong>函数环境记录</strong>还支持表 20 中的方法。</p>
<blockquote>
<p>The behaviour of the additional concrete specification methods for module Environment Records are defined by the following algorithms:</p>
</blockquote>
<p> <strong>模块环境记录</strong>的附加具体规范方法行为被以下的算法定义。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>ECMA</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
